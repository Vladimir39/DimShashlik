{"ast":null,"code":"'use strict';\n\nimport _slicedToArray from \"D:\\\\JS-React\\\\dimshishlik_new_v4\\\\react-course-app\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\slicedToArray.js\";\nimport _classCallCheck from \"D:\\\\JS-React\\\\dimshishlik_new_v4\\\\react-course-app\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"D:\\\\JS-React\\\\dimshishlik_new_v4\\\\react-course-app\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport utils from '../utils.js';\nimport parseHeaders from '../helpers/parseHeaders.js';\nvar $internals = Symbol('internals');\n\nfunction normalizeHeader(header) {\n  return header && String(header).trim().toLowerCase();\n}\n\nfunction normalizeValue(value) {\n  if (value === false || value == null) {\n    return value;\n  }\n\n  return utils.isArray(value) ? value.map(normalizeValue) : String(value);\n}\n\nfunction parseTokens(str) {\n  var tokens = Object.create(null);\n  var tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  var match;\n\n  while (match = tokensRE.exec(str)) {\n    tokens[match[1]] = match[2];\n  }\n\n  return tokens;\n}\n\nvar isValidHeaderName = function isValidHeaderName(str) {\n  return /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());\n};\n\nfunction matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {\n  if (utils.isFunction(filter)) {\n    return filter.call(this, value, header);\n  }\n\n  if (isHeaderNameFilter) {\n    value = header;\n  }\n\n  if (!utils.isString(value)) return;\n\n  if (utils.isString(filter)) {\n    return value.indexOf(filter) !== -1;\n  }\n\n  if (utils.isRegExp(filter)) {\n    return filter.test(value);\n  }\n}\n\nfunction formatHeader(header) {\n  return header.trim().toLowerCase().replace(/([a-z\\d])(\\w*)/g, function (w, char, str) {\n    return char.toUpperCase() + str;\n  });\n}\n\nfunction buildAccessors(obj, header) {\n  var accessorName = utils.toCamelCase(' ' + header);\n  ['get', 'set', 'has'].forEach(function (methodName) {\n    Object.defineProperty(obj, methodName + accessorName, {\n      value: function value(arg1, arg2, arg3) {\n        return this[methodName].call(this, header, arg1, arg2, arg3);\n      },\n      configurable: true\n    });\n  });\n}\n\nvar AxiosHeaders = /*#__PURE__*/function (_Symbol$iterator, _Symbol$toStringTag) {\n  function AxiosHeaders(headers) {\n    _classCallCheck(this, AxiosHeaders);\n\n    headers && this.set(headers);\n  }\n\n  _createClass(AxiosHeaders, [{\n    key: \"set\",\n    value: function set(header, valueOrRewrite, rewrite) {\n      var self = this;\n\n      function setHeader(_value, _header, _rewrite) {\n        var lHeader = normalizeHeader(_header);\n\n        if (!lHeader) {\n          throw new Error('header name must be a non-empty string');\n        }\n\n        var key = utils.findKey(self, lHeader);\n\n        if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) {\n          self[key || _header] = normalizeValue(_value);\n        }\n      }\n\n      var setHeaders = function setHeaders(headers, _rewrite) {\n        return utils.forEach(headers, function (_value, _header) {\n          return setHeader(_value, _header, _rewrite);\n        });\n      };\n\n      if (utils.isPlainObject(header) || header instanceof this.constructor) {\n        setHeaders(header, valueOrRewrite);\n      } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n        setHeaders(parseHeaders(header), valueOrRewrite);\n      } else {\n        header != null && setHeader(valueOrRewrite, header, rewrite);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"get\",\n    value: function get(header, parser) {\n      header = normalizeHeader(header);\n\n      if (header) {\n        var key = utils.findKey(this, header);\n\n        if (key) {\n          var value = this[key];\n\n          if (!parser) {\n            return value;\n          }\n\n          if (parser === true) {\n            return parseTokens(value);\n          }\n\n          if (utils.isFunction(parser)) {\n            return parser.call(this, value, key);\n          }\n\n          if (utils.isRegExp(parser)) {\n            return parser.exec(value);\n          }\n\n          throw new TypeError('parser must be boolean|regexp|function');\n        }\n      }\n    }\n  }, {\n    key: \"has\",\n    value: function has(header, matcher) {\n      header = normalizeHeader(header);\n\n      if (header) {\n        var key = utils.findKey(this, header);\n        return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n      }\n\n      return false;\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(header, matcher) {\n      var self = this;\n      var deleted = false;\n\n      function deleteHeader(_header) {\n        _header = normalizeHeader(_header);\n\n        if (_header) {\n          var key = utils.findKey(self, _header);\n\n          if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n            delete self[key];\n            deleted = true;\n          }\n        }\n      }\n\n      if (utils.isArray(header)) {\n        header.forEach(deleteHeader);\n      } else {\n        deleteHeader(header);\n      }\n\n      return deleted;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(matcher) {\n      var keys = Object.keys(this);\n      var i = keys.length;\n      var deleted = false;\n\n      while (i--) {\n        var key = keys[i];\n\n        if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {\n          delete this[key];\n          deleted = true;\n        }\n      }\n\n      return deleted;\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize(format) {\n      var self = this;\n      var headers = {};\n      utils.forEach(this, function (value, header) {\n        var key = utils.findKey(headers, header);\n\n        if (key) {\n          self[key] = normalizeValue(value);\n          delete self[header];\n          return;\n        }\n\n        var normalized = format ? formatHeader(header) : String(header).trim();\n\n        if (normalized !== header) {\n          delete self[header];\n        }\n\n        self[normalized] = normalizeValue(value);\n        headers[normalized] = true;\n      });\n      return this;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat() {\n      var _this$constructor;\n\n      for (var _len = arguments.length, targets = new Array(_len), _key = 0; _key < _len; _key++) {\n        targets[_key] = arguments[_key];\n      }\n\n      return (_this$constructor = this.constructor).concat.apply(_this$constructor, [this].concat(targets));\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(asStrings) {\n      var obj = Object.create(null);\n      utils.forEach(this, function (value, header) {\n        value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);\n      });\n      return obj;\n    }\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      return Object.entries(this.toJSON())[Symbol.iterator]();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return Object.entries(this.toJSON()).map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            header = _ref2[0],\n            value = _ref2[1];\n\n        return header + ': ' + value;\n      }).join('\\n');\n    }\n  }, {\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return 'AxiosHeaders';\n    }\n  }], [{\n    key: \"from\",\n    value: function from(thing) {\n      return thing instanceof this ? thing : new this(thing);\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(first) {\n      var computed = new this(first);\n\n      for (var _len2 = arguments.length, targets = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        targets[_key2 - 1] = arguments[_key2];\n      }\n\n      targets.forEach(function (target) {\n        return computed.set(target);\n      });\n      return computed;\n    }\n  }, {\n    key: \"accessor\",\n    value: function accessor(header) {\n      var internals = this[$internals] = this[$internals] = {\n        accessors: {}\n      };\n      var accessors = internals.accessors;\n      var prototype = this.prototype;\n\n      function defineAccessor(_header) {\n        var lHeader = normalizeHeader(_header);\n\n        if (!accessors[lHeader]) {\n          buildAccessors(prototype, _header);\n          accessors[lHeader] = true;\n        }\n      }\n\n      utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n      return this;\n    }\n  }]);\n\n  return AxiosHeaders;\n}(Symbol.iterator, Symbol.toStringTag);\n\nAxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);\nutils.freezeMethods(AxiosHeaders.prototype);\nutils.freezeMethods(AxiosHeaders);\nexport default AxiosHeaders;","map":{"version":3,"sources":["D:/JS-React/dimshishlik_new_v4/react-course-app/node_modules/axios/lib/core/AxiosHeaders.js"],"names":["utils","parseHeaders","$internals","Symbol","normalizeHeader","header","String","trim","toLowerCase","normalizeValue","value","isArray","map","parseTokens","str","tokens","Object","create","tokensRE","match","exec","isValidHeaderName","test","matchHeaderValue","context","filter","isHeaderNameFilter","isFunction","call","isString","indexOf","isRegExp","formatHeader","replace","w","char","toUpperCase","buildAccessors","obj","accessorName","toCamelCase","forEach","methodName","defineProperty","arg1","arg2","arg3","configurable","AxiosHeaders","headers","set","valueOrRewrite","rewrite","self","setHeader","_value","_header","_rewrite","lHeader","Error","key","findKey","undefined","setHeaders","isPlainObject","constructor","parser","TypeError","matcher","deleted","deleteHeader","keys","i","length","format","normalized","targets","concat","asStrings","join","entries","toJSON","iterator","thing","first","computed","target","internals","accessors","prototype","defineAccessor","toStringTag","accessor","freezeMethods"],"mappings":"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","sourcesContent":["'use strict';\n\nimport utils from '../utils.js';\nimport parseHeaders from '../helpers/parseHeaders.js';\n\nconst $internals = Symbol('internals');\n\nfunction normalizeHeader(header) {\n  return header && String(header).trim().toLowerCase();\n}\n\nfunction normalizeValue(value) {\n  if (value === false || value == null) {\n    return value;\n  }\n\n  return utils.isArray(value) ? value.map(normalizeValue) : String(value);\n}\n\nfunction parseTokens(str) {\n  const tokens = Object.create(null);\n  const tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  let match;\n\n  while ((match = tokensRE.exec(str))) {\n    tokens[match[1]] = match[2];\n  }\n\n  return tokens;\n}\n\nconst isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());\n\nfunction matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {\n  if (utils.isFunction(filter)) {\n    return filter.call(this, value, header);\n  }\n\n  if (isHeaderNameFilter) {\n    value = header;\n  }\n\n  if (!utils.isString(value)) return;\n\n  if (utils.isString(filter)) {\n    return value.indexOf(filter) !== -1;\n  }\n\n  if (utils.isRegExp(filter)) {\n    return filter.test(value);\n  }\n}\n\nfunction formatHeader(header) {\n  return header.trim()\n    .toLowerCase().replace(/([a-z\\d])(\\w*)/g, (w, char, str) => {\n      return char.toUpperCase() + str;\n    });\n}\n\nfunction buildAccessors(obj, header) {\n  const accessorName = utils.toCamelCase(' ' + header);\n\n  ['get', 'set', 'has'].forEach(methodName => {\n    Object.defineProperty(obj, methodName + accessorName, {\n      value: function(arg1, arg2, arg3) {\n        return this[methodName].call(this, header, arg1, arg2, arg3);\n      },\n      configurable: true\n    });\n  });\n}\n\nclass AxiosHeaders {\n  constructor(headers) {\n    headers && this.set(headers);\n  }\n\n  set(header, valueOrRewrite, rewrite) {\n    const self = this;\n\n    function setHeader(_value, _header, _rewrite) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!lHeader) {\n        throw new Error('header name must be a non-empty string');\n      }\n\n      const key = utils.findKey(self, lHeader);\n\n      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {\n        self[key || _header] = normalizeValue(_value);\n      }\n    }\n\n    const setHeaders = (headers, _rewrite) =>\n      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));\n\n    if (utils.isPlainObject(header) || header instanceof this.constructor) {\n      setHeaders(header, valueOrRewrite)\n    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n      setHeaders(parseHeaders(header), valueOrRewrite);\n    } else {\n      header != null && setHeader(valueOrRewrite, header, rewrite);\n    }\n\n    return this;\n  }\n\n  get(header, parser) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      if (key) {\n        const value = this[key];\n\n        if (!parser) {\n          return value;\n        }\n\n        if (parser === true) {\n          return parseTokens(value);\n        }\n\n        if (utils.isFunction(parser)) {\n          return parser.call(this, value, key);\n        }\n\n        if (utils.isRegExp(parser)) {\n          return parser.exec(value);\n        }\n\n        throw new TypeError('parser must be boolean|regexp|function');\n      }\n    }\n  }\n\n  has(header, matcher) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n    }\n\n    return false;\n  }\n\n  delete(header, matcher) {\n    const self = this;\n    let deleted = false;\n\n    function deleteHeader(_header) {\n      _header = normalizeHeader(_header);\n\n      if (_header) {\n        const key = utils.findKey(self, _header);\n\n        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n          delete self[key];\n\n          deleted = true;\n        }\n      }\n    }\n\n    if (utils.isArray(header)) {\n      header.forEach(deleteHeader);\n    } else {\n      deleteHeader(header);\n    }\n\n    return deleted;\n  }\n\n  clear(matcher) {\n    const keys = Object.keys(this);\n    let i = keys.length;\n    let deleted = false;\n\n    while (i--) {\n      const key = keys[i];\n      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {\n        delete this[key];\n        deleted = true;\n      }\n    }\n\n    return deleted;\n  }\n\n  normalize(format) {\n    const self = this;\n    const headers = {};\n\n    utils.forEach(this, (value, header) => {\n      const key = utils.findKey(headers, header);\n\n      if (key) {\n        self[key] = normalizeValue(value);\n        delete self[header];\n        return;\n      }\n\n      const normalized = format ? formatHeader(header) : String(header).trim();\n\n      if (normalized !== header) {\n        delete self[header];\n      }\n\n      self[normalized] = normalizeValue(value);\n\n      headers[normalized] = true;\n    });\n\n    return this;\n  }\n\n  concat(...targets) {\n    return this.constructor.concat(this, ...targets);\n  }\n\n  toJSON(asStrings) {\n    const obj = Object.create(null);\n\n    utils.forEach(this, (value, header) => {\n      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);\n    });\n\n    return obj;\n  }\n\n  [Symbol.iterator]() {\n    return Object.entries(this.toJSON())[Symbol.iterator]();\n  }\n\n  toString() {\n    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\\n');\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'AxiosHeaders';\n  }\n\n  static from(thing) {\n    return thing instanceof this ? thing : new this(thing);\n  }\n\n  static concat(first, ...targets) {\n    const computed = new this(first);\n\n    targets.forEach((target) => computed.set(target));\n\n    return computed;\n  }\n\n  static accessor(header) {\n    const internals = this[$internals] = (this[$internals] = {\n      accessors: {}\n    });\n\n    const accessors = internals.accessors;\n    const prototype = this.prototype;\n\n    function defineAccessor(_header) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!accessors[lHeader]) {\n        buildAccessors(prototype, _header);\n        accessors[lHeader] = true;\n      }\n    }\n\n    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n\n    return this;\n  }\n}\n\nAxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);\n\nutils.freezeMethods(AxiosHeaders.prototype);\nutils.freezeMethods(AxiosHeaders);\n\nexport default AxiosHeaders;\n"]},"metadata":{},"sourceType":"module"}